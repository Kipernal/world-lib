<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>world-lib: Level Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">world-lib
   </div>
   <div id="projectbrief">Library for getting data from Super Mario World ROMs, mostly related to Lunar Magic hacks and level data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Level Module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceworldlib"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceworldlib.html">worldlib</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9652b9a5cbcd9818b4a76a4fcc3d9b31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___level.html#ga9652b9a5cbcd9818b4a76a4fcc3d9b31">worldlib::GFXSlots</a> { <br/>
&#160;&#160;<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31aec7baafdb4be99ed0e7d17d656eab7b4">worldlib::GFXSlots::FG1</a> = 0, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31ac05b9f186a41e2d40a53a0fb7cb0a999">worldlib::GFXSlots::FG2</a> = 1, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31a8054fb02cd7dfc395f333858f2fcf170">worldlib::GFXSlots::BG1</a> = 2, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31a8ee84b5ddfb7173f86d414b2367e27b6">worldlib::GFXSlots::FG3</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31a510651725fb738f091df7dcea9e1769b">worldlib::GFXSlots::BG2</a> = 4, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31a92e4f3145c805c5fdff6a1a6bfdc9529">worldlib::GFXSlots::BG3</a> = 5, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31ac7ae2402adae054bfa790541a6757b8b">worldlib::GFXSlots::SP1</a> = 6, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31ae9eee470526aff61c234f7dbd238cacc">worldlib::GFXSlots::SP2</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31a6b502d722e3ca80ad25f3a3bbe9e6abb">worldlib::GFXSlots::SP3</a> = 8, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31a45c02c5ac114373df224e3466ba2cd7a">worldlib::GFXSlots::SP4</a> = 9, 
<a class="el" href="group___level.html#gga9652b9a5cbcd9818b4a76a4fcc3d9b31aa667ccc48acad4850cd414ca9cdcbbde">worldlib::GFXSlots::AN2</a> = 10
<br/>
 }</td></tr>
<tr class="memdesc:ga9652b9a5cbcd9818b4a76a4fcc3d9b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the various GFX slots a level can use.  <a href="group___level.html#ga9652b9a5cbcd9818b4a76a4fcc3d9b31">More...</a><br/></td></tr>
<tr class="separator:ga9652b9a5cbcd9818b4a76a4fcc3d9b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4da4325c51154add36154935f0f41677"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:ga4da4325c51154add36154935f0f41677"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga4da4325c51154add36154935f0f41677">worldlib::getLevelPalette</a> (inputIteratorType romStart, inputIteratorType romEnd, outputIteratorType out, int level)</td></tr>
<tr class="memdesc:ga4da4325c51154add36154935f0f41677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified level's palette.  <a href="#ga4da4325c51154add36154935f0f41677">More...</a><br/></td></tr>
<tr class="separator:ga4da4325c51154add36154935f0f41677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad5d44266010076fd93d6d3c8eec966e"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType &gt; </td></tr>
<tr class="memitem:gaad5d44266010076fd93d6d3c8eec966e"><td class="memTemplItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#gaad5d44266010076fd93d6d3c8eec966e">worldlib::getLevelBackgroundColor</a> (inputIteratorType romStart, inputIteratorType romEnd, int level)</td></tr>
<tr class="memdesc:gaad5d44266010076fd93d6d3c8eec966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified level's background color.  <a href="#gaad5d44266010076fd93d6d3c8eec966e">More...</a><br/></td></tr>
<tr class="separator:gaad5d44266010076fd93d6d3c8eec966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727fae6cb1b015bd05ad3f46a5a10b14"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:ga727fae6cb1b015bd05ad3f46a5a10b14"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga727fae6cb1b015bd05ad3f46a5a10b14">worldlib::getLevelGraphicsSlots</a> (inputIteratorType romStart, inputIteratorType romEnd, outputIteratorType out, int level)</td></tr>
<tr class="memdesc:ga727fae6cb1b015bd05ad3f46a5a10b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all 11 of the specified level's graphics slots.  <a href="#ga727fae6cb1b015bd05ad3f46a5a10b14">More...</a><br/></td></tr>
<tr class="separator:ga727fae6cb1b015bd05ad3f46a5a10b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18620e3869b1b5e28556fd58acceb1d"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:gaa18620e3869b1b5e28556fd58acceb1d"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#gaa18620e3869b1b5e28556fd58acceb1d">worldlib::getLevelBackgroundGraphicsSlots</a> (inputIteratorType romStart, inputIteratorType romEnd, outputIteratorType out, int level)</td></tr>
<tr class="memdesc:gaa18620e3869b1b5e28556fd58acceb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all 6 of the specified level's FG/BG slots in the standard order of FG1, FG2, BG1, FG3, BG2, BG3.  <a href="#gaa18620e3869b1b5e28556fd58acceb1d">More...</a><br/></td></tr>
<tr class="separator:gaa18620e3869b1b5e28556fd58acceb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026af01e7e599857599012d39486ad6d"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:ga026af01e7e599857599012d39486ad6d"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga026af01e7e599857599012d39486ad6d">worldlib::getLevelSpriteGraphicsSlots</a> (inputIteratorType romStart, inputIteratorType romEnd, outputIteratorType out, int level)</td></tr>
<tr class="memdesc:ga026af01e7e599857599012d39486ad6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all 4 of the specified level's FG/BG slots in the standard order of SP1, SP2, SP3, SP4.  <a href="#ga026af01e7e599857599012d39486ad6d">More...</a><br/></td></tr>
<tr class="separator:ga026af01e7e599857599012d39486ad6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec002ae1838f747b4fadf079ee212363"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType &gt; </td></tr>
<tr class="memitem:gaec002ae1838f747b4fadf079ee212363"><td class="memTemplItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#gaec002ae1838f747b4fadf079ee212363">worldlib::getLevelAnimatedTileAreaGraphicsSlot</a> (inputIteratorType romStart, inputIteratorType romEnd, int level)</td></tr>
<tr class="memdesc:gaec002ae1838f747b4fadf079ee212363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified level's animated tile slot. Keep in mind that animated graphics files can be more than 4kb!  <a href="#gaec002ae1838f747b4fadf079ee212363">More...</a><br/></td></tr>
<tr class="separator:gaec002ae1838f747b4fadf079ee212363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ddb470a2b6dfbc10b89c67c8db89efc"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType &gt; </td></tr>
<tr class="memitem:ga4ddb470a2b6dfbc10b89c67c8db89efc"><td class="memTemplItemLeft" align="right" valign="top">std::uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga4ddb470a2b6dfbc10b89c67c8db89efc">worldlib::getLevelSingleGraphicsSlot</a> (inputIteratorType romStart, inputIteratorType romEnd, int level, GFXSlots slotToGet)</td></tr>
<tr class="memdesc:ga4ddb470a2b6dfbc10b89c67c8db89efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified level's specified tile slot. Keep in mind that animated graphics files can be more than 4kb!  <a href="#ga4ddb470a2b6dfbc10b89c67c8db89efc">More...</a><br/></td></tr>
<tr class="separator:ga4ddb470a2b6dfbc10b89c67c8db89efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6065d41c35be414842a05acf18a806e8"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:ga6065d41c35be414842a05acf18a806e8"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga6065d41c35be414842a05acf18a806e8">worldlib::decompressGraphicsFile</a> (inputIteratorType romStart, inputIteratorType romEnd, outputIteratorType out, int file, int *compressedSize=nullptr, int *decompressedSize=nullptr)</td></tr>
<tr class="memdesc:ga6065d41c35be414842a05acf18a806e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses the specified level's specified graphics slot into an indexed bitmap. In other words, it's like calling decompressLZX but automatically gives it the correct parameters based on the level and slots you choose (and based on whether the ROM uses LZ2 or LZ3 decompression).  <a href="#ga6065d41c35be414842a05acf18a806e8">More...</a><br/></td></tr>
<tr class="separator:ga6065d41c35be414842a05acf18a806e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d6170d181a7452ea457bbe07ceca40"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType &gt; </td></tr>
<tr class="memitem:ga38d6170d181a7452ea457bbe07ceca40"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga38d6170d181a7452ea457bbe07ceca40">worldlib::getAddressOfGraphicsFile</a> (inputIteratorType romStart, inputIteratorType romEnd, int file)</td></tr>
<tr class="memdesc:ga38d6170d181a7452ea457bbe07ceca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the specified graphics file.  <a href="#ga38d6170d181a7452ea457bbe07ceca40">More...</a><br/></td></tr>
<tr class="separator:ga38d6170d181a7452ea457bbe07ceca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4c1c428e12c0ecc3172421e4a6e6e9"><td class="memTemplParams" colspan="2">template&lt;typename inputIteratorType &gt; </td></tr>
<tr class="memitem:ga2c4c1c428e12c0ecc3172421e4a6e6e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga2c4c1c428e12c0ecc3172421e4a6e6e9">worldlib::romContainsGraphicsFile</a> (inputIteratorType romStart, inputIteratorType romEnd, int file)</td></tr>
<tr class="memdesc:ga2c4c1c428e12c0ecc3172421e4a6e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified graphics file exists.  <a href="#ga2c4c1c428e12c0ecc3172421e4a6e6e9">More...</a><br/></td></tr>
<tr class="separator:ga2c4c1c428e12c0ecc3172421e4a6e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca1367031baf521b593ac01016667db"><td class="memTemplParams" colspan="2">template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:ga7ca1367031baf521b593ac01016667db"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga7ca1367031baf521b593ac01016667db">worldlib::indexedImageToBitmap</a> (graphicsInputIteratorType graphicsFileStart, graphicsInputIteratorType graphicsFileEnd, paletteInputIteratorType paletteStart, paletteInputIteratorType paletteEnd, int tilesInOneRow, int bpp, int paletteNumber, outputIteratorType out, int *resultingWidth=nullptr, int *resultingHeight=nullptr)</td></tr>
<tr class="memdesc:ga7ca1367031baf521b593ac01016667db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an indexed bitmap to a normal ARGB one.  <a href="#ga7ca1367031baf521b593ac01016667db">More...</a><br/></td></tr>
<tr class="separator:ga7ca1367031baf521b593ac01016667db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b057895e84602bdfbcf916167dc4470"><td class="memTemplParams" colspan="2">template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:ga2b057895e84602bdfbcf916167dc4470"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#ga2b057895e84602bdfbcf916167dc4470">worldlib::indexedImageToBitmap</a> (graphicsInputIteratorType graphicsFileStart, graphicsInputIteratorType graphicsFileEnd, paletteInputIteratorType paletteStart, paletteInputIteratorType paletteEnd, int tilesInOneRow, int bpp, int x, int y, int width, int height, bool flipX, bool flipY, int paletteNumber, outputIteratorType out, int *resultingWidth=nullptr, int *resultingHeight=nullptr)</td></tr>
<tr class="memdesc:ga2b057895e84602bdfbcf916167dc4470"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Super Triple Deluxe version of indexedImageToBitmap that does everything. Probably more than you might need it to, if for no other reason than it's huge.  <a href="#ga2b057895e84602bdfbcf916167dc4470">More...</a><br/></td></tr>
<tr class="separator:ga2b057895e84602bdfbcf916167dc4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb7c08f208b0ec16fabffcfe073698b"><td class="memTemplParams" colspan="2">template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:gaedb7c08f208b0ec16fabffcfe073698b"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#gaedb7c08f208b0ec16fabffcfe073698b">worldlib::indexedImageToBitmap</a> (graphicsInputIteratorType graphicsFileStart, graphicsInputIteratorType graphicsFileEnd, paletteInputIteratorType paletteStart, paletteInputIteratorType paletteEnd, int bpp, int paletteNumber, outputIteratorType out, int *resultingWidth=nullptr, int *resultingHeight=nullptr)</td></tr>
<tr class="memdesc:gaedb7c08f208b0ec16fabffcfe073698b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplest version of indexedImageToBitmap that gets the entire image and assumes some defaults.  <a href="#gaedb7c08f208b0ec16fabffcfe073698b">More...</a><br/></td></tr>
<tr class="separator:gaedb7c08f208b0ec16fabffcfe073698b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9d61f88336120b22046da5ed053657"><td class="memTemplParams" colspan="2">template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </td></tr>
<tr class="memitem:gada9d61f88336120b22046da5ed053657"><td class="memTemplItemLeft" align="right" valign="top">outputIteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___level.html#gada9d61f88336120b22046da5ed053657">worldlib::indexedImageToBitmap</a> (graphicsInputIteratorType graphicsStart, graphicsInputIteratorType graphicsEnd, paletteInputIteratorType paletteStart, paletteInputIteratorType paletteEnd, int bpp, bool flipX, bool flipY, int paletteNumber, outputIteratorType out)</td></tr>
<tr class="memdesc:gada9d61f88336120b22046da5ed053657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an indexed tile, or multiple indexed tiles, into an ARGB bitmap with a height of 8 pixels and a width of 8 x number of tiles decoded pixels. It's recommended to just decode one 8x8 tile at a time, but even more recommended is to just use the other functions. They'll give you an actual image instead of a very short very wide image.  <a href="#gada9d61f88336120b22046da5ed053657">More...</a><br/></td></tr>
<tr class="separator:gada9d61f88336120b22046da5ed053657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module for getting data from levels, including their graphics </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga9652b9a5cbcd9818b4a76a4fcc3d9b31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___level.html#ga9652b9a5cbcd9818b4a76a4fcc3d9b31">worldlib::GFXSlots</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the various GFX slots a level can use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31aec7baafdb4be99ed0e7d17d656eab7b4"></a>FG1</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31ac05b9f186a41e2d40a53a0fb7cb0a999"></a>FG2</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31a8054fb02cd7dfc395f333858f2fcf170"></a>BG1</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31a8ee84b5ddfb7173f86d414b2367e27b6"></a>FG3</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31a510651725fb738f091df7dcea9e1769b"></a>BG2</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31a92e4f3145c805c5fdff6a1a6bfdc9529"></a>BG3</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31ac7ae2402adae054bfa790541a6757b8b"></a>SP1</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31ae9eee470526aff61c234f7dbd238cacc"></a>SP2</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31a6b502d722e3ca80ad25f3a3bbe9e6abb"></a>SP3</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31a45c02c5ac114373df224e3466ba2cd7a"></a>SP4</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9652b9a5cbcd9818b4a76a4fcc3d9b31aa667ccc48acad4850cd414ca9cdcbbde"></a>AN2</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_level_8hpp_source.html#l00021">21</a> of file <a class="el" href="_level_8hpp_source.html">Level.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6065d41c35be414842a05acf18a806e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::decompressGraphicsFile </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>compressedSize</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>decompressedSize</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompresses the specified level's specified graphics slot into an indexed bitmap. In other words, it's like calling decompressLZX but automatically gives it the correct parameters based on the level and slots you choose (and based on whether the ROM uses LZ2 or LZ3 decompression). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">out</td><td>Where to output the data </td></tr>
    <tr><td class="paramname">file</td><td>The file to decompress </td></tr>
    <tr><td class="paramname">compressedSize</td><td>Will contain the size of the compressed data after the function ends if it is not nullptr </td></tr>
    <tr><td class="paramname">decompressedSize</td><td>Will contain the size of the decompressed data after the function ends if it is not nullptr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your decompressed image data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If there is an error decompressing the data, such as a corrupted graphics file (see decompressLZ2 and decompressLZ3), if the ROM uses an unrecognized compression format, or if the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___decompression.html#ga9bbd5e6e097e7ea02f6c7da6f6dd279a" title="Decompresses data compressed in the LZ2 format. ">decompressLZ2</a>, <a class="el" href="group___decompression.html#ga2634aa7242226380ca7310dde403a253" title="Decompresses data compressed in the LZ3 format. ">decompressLZ3</a> </dd></dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00270">270</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga38d6170d181a7452ea457bbe07ceca40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int worldlib::getAddressOfGraphicsFile </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address of the specified graphics file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">file</td><td>The graphics file to get the address of. Valid for all types of graphics: normal, Standard ExGFX, and Super ExGFX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SNES address of the file in the ROM. Returns -1 for file 0x7F, though you should always have special handling anyway for this "file".</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the graphics file does not exist in the ROM or is otherwise invalid, or if the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through table data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00228">228</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="gaec002ae1838f747b4fadf079ee212363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t worldlib::getLevelAnimatedTileAreaGraphicsSlot </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified level's animated tile slot. Keep in mind that animated graphics files can be more than 4kb! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the graphics slots from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animated tile graphics slot of the specified level</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00204">204</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="gaad5d44266010076fd93d6d3c8eec966e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t worldlib::getLevelBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified level's background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the background color from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color, in ARGB format</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00119">119</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="gaa18620e3869b1b5e28556fd58acceb1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::getLevelBackgroundGraphicsSlots </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all 6 of the specified level's FG/BG slots in the standard order of FG1, FG2, BG1, FG3, BG2, BG3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">out</td><td>Where to output the data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the graphics slots from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your slot list data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00148">148</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga727fae6cb1b015bd05ad3f46a5a10b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::getLevelGraphicsSlots </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all 11 of the specified level's graphics slots. </p>
<p>The order is in the standard order of FG1, FG2, BG1, FG3, BG2, BG3, SP1, SP2, SP3, SP4, AN2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">out</td><td>Where to output the data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the graphics slots from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your slot list data.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00138">138</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga4da4325c51154add36154935f0f41677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::getLevelPalette </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified level's palette. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">out</td><td>Where to output the data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the palette from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your color data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00109">109</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ddb470a2b6dfbc10b89c67c8db89efc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint16_t worldlib::getLevelSingleGraphicsSlot </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GFXSlots&#160;</td>
          <td class="paramname"><em>slotToGet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the specified level's specified tile slot. Keep in mind that animated graphics files can be more than 4kb! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the graphics slots from </td></tr>
    <tr><td class="paramname">slotToGet</td><td>The level's slot to return</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animated tile graphics slot of the specified level</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00220">220</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga026af01e7e599857599012d39486ad6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::getLevelSpriteGraphicsSlots </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all 4 of the specified level's FG/BG slots in the standard order of SP1, SP2, SP3, SP4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">out</td><td>Where to output the data </td></tr>
    <tr><td class="paramname">level</td><td>The level to get the graphics slots from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your slot list data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through level data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00178">178</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ca1367031baf521b593ac01016667db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::indexedImageToBitmap </td>
          <td>(</td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsFileStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsFileEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tilesInOneRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paletteNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultingWidth</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultingHeight</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an indexed bitmap to a normal ARGB one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsFileStart</td><td>An iterator pointing to the start of the graphics file to convert </td></tr>
    <tr><td class="paramname">graphicsFileEnd</td><td>An iterator pointing to the end of the graphics file to convert </td></tr>
    <tr><td class="paramname">paletteStart</td><td>An iterator pointing to the start of the palette to use in conversion </td></tr>
    <tr><td class="paramname">paletteEnd</td><td>An iterator pointing to the end of the palette to use in conversion </td></tr>
    <tr><td class="paramname">tilesInOneRow</td><td>How many 8x8 tiles are in one row. Chances are 0x10 is just fine here. </td></tr>
    <tr><td class="paramname">bpp</td><td>The bpp to use for conversion. Only 2, 4, and 8 are valid. </td></tr>
    <tr><td class="paramname">paletteNumber</td><td>The palette number to use for conversion. If the bpp is 8, this should be 0 unless your palette is for some reason larger than a standard SFC palette </td></tr>
    <tr><td class="paramname">out</td><td>Where to send the decoded data. It's just a stream of data&ndash;the following two parameters determine how the raw data should be interpreted in terms of width and height. Highly recommended to use ColorBackInsertIterator to control how the color data is inserted. </td></tr>
    <tr><td class="paramname">resultingWidth</td><td>Will contain the width of the image after the function ends if it is not nullptr </td></tr>
    <tr><td class="paramname">resultingHeight</td><td>Will contain the height of the image after the function ends if it is not nullptr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your converted image data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the graphics file has a pixel that refers to a palette entry that does not exist </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00492">492</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b057895e84602bdfbcf916167dc4470"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::indexedImageToBitmap </td>
          <td>(</td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsFileStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsFileEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tilesInOneRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paletteNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultingWidth</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultingHeight</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Super Triple Deluxe version of indexedImageToBitmap that does everything. Probably more than you might need it to, if for no other reason than it's huge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsFileStart</td><td>An iterator pointing to the start of the graphics file to convert </td></tr>
    <tr><td class="paramname">graphicsFileEnd</td><td>An iterator pointing to the end of the graphics file to convert </td></tr>
    <tr><td class="paramname">paletteStart</td><td>An iterator pointing to the start of the palette to use in conversion </td></tr>
    <tr><td class="paramname">paletteEnd</td><td>An iterator pointing to the end of the palette to use in conversion </td></tr>
    <tr><td class="paramname">tilesInOneRow</td><td>How many 8x8 tiles are in one row. Chances are 0x10 is just fine here. </td></tr>
    <tr><td class="paramname">bpp</td><td>The bpp to use for conversion. Only 2, 4, and 8 are valid. </td></tr>
    <tr><td class="paramname">x</td><td>The x position of the "window" of the indexed graphics to convert </td></tr>
    <tr><td class="paramname">y</td><td>The y position of the "window" of the indexed graphics to convert </td></tr>
    <tr><td class="paramname">width</td><td>The width of the "window" of the indexed graphics to convert. If -1, will be treated as "to the rightmost edge of the image" </td></tr>
    <tr><td class="paramname">height</td><td>The height of the "window" of the indexed graphics to convert. If -1, will be treated as "to the bottommost edge of the image" </td></tr>
    <tr><td class="paramname">flipX</td><td>Will flip all TILES (not the image itself, but the individual tiles) horizontally </td></tr>
    <tr><td class="paramname">flipY</td><td>Will flip all TILES (not the image itself, but the individual tiles) vertically </td></tr>
    <tr><td class="paramname">paletteNumber</td><td>The palette number to use for conversion. If the bpp is 8, this should be 0 unless your palette is for some reason larger than a standard SFC palette </td></tr>
    <tr><td class="paramname">out</td><td>Where to send the decoded data. It's just a stream of data&ndash;the following two parameters determine how the raw data should be interpreted in terms of width and height. Highly recommended to use ColorBackInsertIterator to control how the color data is inserted. </td></tr>
    <tr><td class="paramname">resultingWidth</td><td>Will contain the width of the image after the function ends if it is not nullptr. Mostly useful if width is -1, since it will tell you how wide the image you got was. </td></tr>
    <tr><td class="paramname">resultingHeight</td><td>Will contain the height of the image after the function ends if it is not nullptr. Mostly useful if the height is -1, since it will tell you how tall the image you got was.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your converted image data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the graphics file has a pixel that refers to a palette entry that does not exist </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00401">401</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="gaedb7c08f208b0ec16fabffcfe073698b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::indexedImageToBitmap </td>
          <td>(</td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsFileStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsFileEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paletteNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultingWidth</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resultingHeight</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplest version of indexedImageToBitmap that gets the entire image and assumes some defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsFileStart</td><td>An iterator pointing to the start of the graphics file to convert </td></tr>
    <tr><td class="paramname">graphicsFileEnd</td><td>An iterator pointing to the end of the graphics file to convert </td></tr>
    <tr><td class="paramname">paletteStart</td><td>An iterator pointing to the start of the palette to use in conversion </td></tr>
    <tr><td class="paramname">paletteEnd</td><td>An iterator pointing to the end of the palette to use in conversion </td></tr>
    <tr><td class="paramname">bpp</td><td>The bpp to use for conversion. Only 2, 4, and 8 are valid. </td></tr>
    <tr><td class="paramname">paletteNumber</td><td>The palette number to use for conversion. If the bpp is 8, this should be 0 unless your palette is for some reason larger than a standard SFC palette </td></tr>
    <tr><td class="paramname">out</td><td>Where to send the decoded data. It's just a stream of data&ndash;the following two parameters determine how the raw data should be interpreted in terms of width and height. Highly recommended to use ColorBackInsertIterator to control how the color data is inserted. </td></tr>
    <tr><td class="paramname">resultingWidth</td><td>Will contain the width of the image after the function ends if it is not nullptr. Mostly useful if width is -1, since it will tell you how wide the image you got was. </td></tr>
    <tr><td class="paramname">resultingHeight</td><td>Will contain the height of the image after the function ends if it is not nullptr. Mostly useful if the height is -1, since it will tell you how tall the image you got was.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your converted image data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the graphics file has a pixel that refers to a palette entry that does not exist </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00498">498</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="gada9d61f88336120b22046da5ed053657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename graphicsInputIteratorType , typename paletteInputIteratorType , typename outputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">outputIteratorType worldlib::indexedImageToBitmap </td>
          <td>(</td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">graphicsInputIteratorType&#160;</td>
          <td class="paramname"><em>graphicsEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">paletteInputIteratorType&#160;</td>
          <td class="paramname"><em>paletteEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paletteNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">outputIteratorType&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an indexed tile, or multiple indexed tiles, into an ARGB bitmap with a height of 8 pixels and a width of 8 x number of tiles decoded pixels. It's recommended to just decode one 8x8 tile at a time, but even more recommended is to just use the other functions. They'll give you an actual image instead of a very short very wide image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphicsStart</td><td>An iterator pointing to the start of the graphics to convert </td></tr>
    <tr><td class="paramname">graphicsEnd</td><td>An iterator pointing to the end of the graphics to convert </td></tr>
    <tr><td class="paramname">paletteStart</td><td>An iterator pointing to the start of the palette to use in conversion </td></tr>
    <tr><td class="paramname">paletteEnd</td><td>An iterator pointing to the end of the palette to use in conversion </td></tr>
    <tr><td class="paramname">bpp</td><td>The bpp to use for conversion. Only 2, 4, and 8 are valid. </td></tr>
    <tr><td class="paramname">flipX</td><td>Will flip all TILES (not the image itself, but the individual tiles) horizontally </td></tr>
    <tr><td class="paramname">flipY</td><td>Will flip all TILES (not the image itself, but the individual tiles) vertically </td></tr>
    <tr><td class="paramname">paletteNumber</td><td>The palette number to use for conversion. If the bpp is 8, this should be 0 unless your palette is for some reason larger than a standard SFC palette </td></tr>
    <tr><td class="paramname">out</td><td>Where to send the decoded data. It's just a stream of data&ndash;the following two parameters determine how the raw data should be interpreted in terms of width and height. Highly recommended to use ColorBackInsertIterator to control how the color data is inserted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to the end of your converted image data</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the graphics file has a pixel that refers to a palette entry that does not exist </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00293">293</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c4c1c428e12c0ecc3172421e4a6e6e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename inputIteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool worldlib::romContainsGraphicsFile </td>
          <td>(</td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">inputIteratorType&#160;</td>
          <td class="paramname"><em>romEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified graphics file exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">romStart</td><td>An iterator pointing to the beginning of the ROM data </td></tr>
    <tr><td class="paramname">romEnd</td><td>An iterator pointing to the end of the ROM data </td></tr>
    <tr><td class="paramname">file</td><td>The graphics file to get the address of. Valid for all types of graphics: normal, Standard ExGFX, and Super ExGFX.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file exists, false if it doesn't. Always returns true for file 0x7F, though you should always have special handling anyway for this "file".</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the ROM did not contain this data (e.g. via invalid pointers or the ROM being cut-off partway through table data or something else weird like that) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_level_8inl_source.html#l00249">249</a> of file <a class="el" href="_level_8inl_source.html">Level.inl</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 7 2014 23:55:21 for world-lib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
